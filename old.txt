// func sendOffer(packet_slice []byte, config c.Configurations) {
// 	dhcp_packet := gopacket.NewPacket(packet_slice, layers.LayerTypeEthernet, gopacket.Default)
//     ethLayer := dhcp_packet.Layer(layers.LayerTypeEthernet)
// 	ethernetPacket, _ := ethLayer.(*layers.Ethernet)

// 	broadcastIP := net.IPv4(255, 255, 255, 255)
// 	offeredIP := generateAddr()
// 	ipLayer := &layers.IPv4{
// 		SrcIP: net.ParseIP(config.Server.ServerAddr),
// 		// Set the destination as broadcast
// 		DstIP: broadcastIP,
// 	}

// 	srcMac, err := net.ParseMAC(config.Metal.HardwareAddr)
// 	if err != nil {
// 		log.Fatalf("Error occured while parsing server Hardware addr")
// 	}

// 	ethernetLayer := &layers.Ethernet{
//         SrcMAC: srcMac,
// 		DstMAC: ethernetPacket.SrcMAC,
// 		EthernetType: layers.EthernetTypeIPv4,
//     }
// 	udpLayer := &layers.UDP{
//         SrcPort: layers.UDPPort(67),
//         DstPort: layers.UDPPort(68),
//     }

// 	udpLayer.SetNetworkLayerForChecksum(ipLayer)

// 	msgTypeOption := layers.NewDHCPOption(layers.DHCPOptMessageType, []byte{byte(layers.DHCPMsgTypeOffer)})

//     // Collect them into a DHCPOptions slice
//     dhcpOptions := layers.DHCPOptions{
//         msgTypeOption,
//     }
// 	dhcpLayer, _ := constructOfferLayer(packet_slice, offeredIP, dhcpOptions, config) // Returns pointer to what was affected

// 	// Set the UDP layer len
// 	udpLength := uint16(8 + len(dhcpLayer.Contents))
// 	udpLayer.Length = udpLength

// 	options := gopacket.SerializeOptions{}
// 	buffer := gopacket.NewSerializeBuffer()
// 	serialErr := gopacket.SerializeLayers(buffer, options, 
// 		ethernetLayer,
// 		ipLayer,
// 		udpLayer,
// 		dhcpLayer,
// 	)
// 	if serialErr != nil {
// 		log.Fatalf("Error occured while serializing layers: %v", serialErr)
// 	}

// 	outgoingPacket := buffer.Bytes()

// 	conn, err := net.ListenPacket("ip4:udp", "0.0.0.0")
// 	if err != nil {
// 		log.Printf("Error creating raw socket for sending offer: %v", err)
// 		return
// 	}
// 	defer conn.Close()

// 	addr := &net.IPAddr{IP: broadcastIP}
// 	_, err = conn.WriteTo(outgoingPacket, addr)
// 	if err != nil {
// 		log.Printf("Error sending packet: %v", err)
// 		return
// 	}

// 	log.Printf("DHCP Offer packet sent to %v", broadcastIP.String())
// 	// addr := fmt.Sprintf("%v:68", offeredIP)
// 	// clientAddr, err := net.ResolveUDPAddr("udp", addr)
// 	// if err != nil {
// 	// 	log.Fatal(err)
// 	// }

// 	// conn, err := net.DialUDP("udp", nil, clientAddr)
// 	// if err != nil {
// 	// 	log.Fatal(err)
// 	// }
// 	// defer conn.Close()

// 	// _, err = conn.Write(outgoingPacket)
// 	// if err != nil {
// 	// 	log.Fatal(err)
// 	// }

// 	// Just for windows debugging, get all devices and use the first one
// 	// devices, _ := pcap.FindAllDevs()
// 	// for _, device := range devices {
// 	// 	fmt.Println(device.Name)
// 	// 	fmt.Println(device.Description)
// 	// }

// 	// Windows interface \\Device\\NPF_{3C62326A-1389-4DB7-BCF8-55747D0B8757}
// 	// Linux interface enp0s31f6

// 	// handle, err := pcap.OpenLive("enp6s18", 67, true, pcap.BlockForever)

// 	// if err != nil {
// 	// 	log.Fatal(err)
// 	// }
// 	// defer handle.Close()

// 	// err = handle.WritePacketData(outgoingPacket)
//     // if err != nil {
//     //     log.Fatal(err)
//     // }
// }

// MAIN
// config, err := readConfig(); if err != nil {
// 	log.Fatalf("Error parsing config file: %v", err)
// }

// fmt.Printf(config.Server.DNS)

// var ip net.IP
// interfaceName := config.Metal.Interface
// hardwareAddr, err := net.ParseMAC(config.Metal.HardwareAddr)
// fmt.Printf(config.Metal.HardwareAddr)

// if interfaceName == "any" {
// 	ip = net.IPv4zero
// } else if interfaceName != "any" {
// 	addr, err := getInterfaceIP(interfaceName); if err != nil {
// 		log.Fatalf("Error occured when getting the IP for interface")
// 	}
// 	ip = addr
// }

// // ha, err := getInterfaceHA(interfaceName)
// fmt.Printf(hardwareAddr.String())

// // Listen for incoming UDP packets on port 67 on this addr
// addr := net.UDPAddr{
//     Port: config.Server.Port,
//     IP:   ip,
// }

// conn, err := net.ListenUDP("udp", &addr)
// if err != nil {
//     log.Fatalf("Error listening on UDP port %d: %v", DHCPServerPort, err)
// }

// // Close the connection upon exit even though its an endless loop
// defer conn.Close()

// // Start main loop to receive packets
// for {
//     // Buffer to hold incoming packet
//     buffer := make([]byte, BufferSize)
    
//     // Receive the UDP packet
//     n, clientAddr, err := conn.ReadFromUDP(buffer)
//     if err != nil {
//         log.Printf("Error receiving packet: %v", err)
//         continue
//     }
    
//     // Start goroutine to handle the packet
//     go handleDHCPPacket(buffer[:n], clientAddr, config)
// }

// Bootp operation, above DHCP Options
// switch dhcp.Operation {
// case layers.DHCPOpRequest:
// 	log.Printf("Bootp packet is Request")
// case layers.DHCPOpReply:
// 	log.Printf("Bootp packet is Reply")
// default:
// 	log.Printf("Error, no Operation specified, I should be confused")
// }

// message, found := getDHCPOption(dhcp.Options, layers.DHCPOptMessageType)